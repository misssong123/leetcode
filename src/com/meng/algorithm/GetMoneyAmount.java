package com.meng.algorithm;

/**
 * 375. 猜数字大小 II
 * 我们正在玩一个猜数游戏，游戏规则如下：
 *
 * 我从 1 到 n 之间选择一个数字。
 * 你来猜我选了哪个数字。
 * 如果你猜到正确的数字，就会 赢得游戏 。
 * 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
 * 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
 * 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：n = 10
 * 输出：16
 * 解释：制胜策略如下：
 * - 数字范围是 [1,10] 。你先猜测数字为 7 。
 *     - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
 *     - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
 *         - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
 *         - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
 *         - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
 *     - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
 *         - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
 *         - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
 *             - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
 *             - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
 *             - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
 *         - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
 *             - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
 *             - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
 * 在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
 * 示例 2：
 *
 * 输入：n = 1
 * 输出：0
 * 解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
 * 示例 3：
 *
 * 输入：n = 2
 * 输出：1
 * 解释：有两个可能的数字 1 和 2 。
 * - 你可以先猜 1 。
 *     - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
 *     - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
 * 最糟糕的情况下，你需要支付 $1 。
 *
 *
 * 提示：
 *
 * 1 <= n <= 200
 */
public class GetMoneyAmount {
    /**
     * 执行用时：
     * 17 ms
     * , 在所有 Java 提交中击败了
     * 78.65%
     * 的用户
     * 内存消耗：
     * 36.8 MB
     * , 在所有 Java 提交中击败了
     * 99.72%
     * 的用户
     * 通过测试用例：
     * 27 / 27
     * @param n
     * @return
     */
    public int getMoneyAmount(int n) {
        int[][] f = new int[n + 1][n + 1];
        for (int i = n - 1; i >= 1; i--) {
            for (int j = i + 1; j <= n; j++) {
                int minCost = Integer.MAX_VALUE;
                for (int k = i; k < j; k++) {
                    int cost = k + Math.max(f[i][k - 1], f[k + 1][j]);
                    minCost = Math.min(minCost, cost);
                }
                f[i][j] = minCost;
            }
        }
        return f[1][n];
    }

    /**
     * 执行用时：
     * 21 ms
     * , 在所有 Java 提交中击败了
     * 35.39%
     * 的用户
     * 内存消耗：
     * 37.4 MB
     * , 在所有 Java 提交中击败了
     * 85.39%
     * 的用户
     * 通过测试用例：
     * 27 / 27
     * @param n
     * @return
     */
    public int getMoneyAmount1(int n) {
        //ans[i][j]表示的是猜从i到j的数字最少需要多少钱
        int ans[][]=new int[n+1][n+1];
        for(int i=1;i<n;i++){ans[i][i+1]=i;}
        for(int d=2;d<n;d++){
            for(int i=1;i<=n-d;i++){
                ans[i][i+d]=Math.min(i+ans[i+1][i+d],i+d+ans[i][i+d-1]);
                for(int j=i+1;j<i+d;j++){ans[i][i+d]=Math.min(ans[i][i+d],j+Math.max(ans[i][j-1],ans[j+1][i+d]));}
            }
        }
        return ans[1][n];
    }
    /**动态规划
     设c[i][j]表示答案位于[i,j]时需要准备的最小金额。
     当选择x（i <= x <= j）时，应该准备的金额是x+max(c[i][max(x-1, i)], c[min(x+1, j)][j])。
     当i == j时，金额为0，因此以[i,j]区间长度作为最外层遍历。
     执行用时：
     20 ms
     , 在所有 Java 提交中击败了
     53.37%
     的用户
     内存消耗：
     37.6 MB
     , 在所有 Java 提交中击败了
     41.57%
     的用户
     通过测试用例：
     27 / 27
     */
        public int getMoneyAmount2(int n) {
            int[][] c = new int[n+1][n+1];
            for (int l=2; l<=n; ++l){    // 区间[i,j]长度逐渐增加, j = i+l-1
                for (int i=1; i<=n-l+1; ++i){
                    int j = i+l-1;
                    c[i][j] = Integer.MAX_VALUE;
                    for (int x=i+1; x<j; ++x){   // 遍历所有可以猜的数字，取最小
                        int cost = x+Math.max(c[i][x-1], c[x+1][j]);
                        c[i][j] = Math.min(c[i][j], cost);
                    }
                    // 处理端点情况
                    c[i][j] = Math.min(c[i][j], i+c[i+1][j]);
                    c[i][j] = Math.min(c[i][j], j+c[i][j-1]);
                }
            }
            return c[1][n];
        }
}
